---
title: 'Understanding useEffectEvent in React 19'
publishedAt: '2025-10-25'
summary: 'A deep dive into the new useEffectEvent hook in React 19 â€” what problem it solves and how to use it effectively.'
---

React **19.2.0** introduced a new hook called `useEffectEvent`.
In this post, we'll walk through a practical example to understand why this hook exists and how it improves real-world React code.

---

## ðŸ§  What is `useEffectEvent`?

`useEffectEvent` is a new React Hook that lets you **extract non-reactive logic** from your Effects into a reusable function called an [Effect Event](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event).

Don't understand? Let's jump right into the example where we can see the need for this hook.

---

## ðŸ’¬ Scenario

Imagine you're building a simple chat room.  
You want to show a "connected" notification when the user successfully connects to a room. The user can also change their name (`userName`) at any time.

Here's how you might implement it at first:

```tsx
import { useEffect } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, userName }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification(`Hi ${userName}, you are now connected!`);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, userName]);
}
```

## ðŸ¤” What's the problem?

At first glance, this looks fine â€” but there's a subtle issue.
When the `userName` changes, the effect re-runs. This means the component disconnects and reconnects to the server unnecessarily.
Also, the â€œConnected!â€ notification will show again, even though the user was already connected.

You might be tempted to fix it like this:
```tsx
function ChatRoom({ roomId, userName }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification(`Hi ${userName}, you are now connected!`);
    });
    connection.connect();
    return () => connection.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);
}
```


But this introduces another problem â€” the effect won't re-run when `userName` changes, so it will display an outdated name if the user connects to a new room later.


## ðŸ’¡ The Solution: `useEffectEvent`

Here's how we can fix the problems elegantly:
```tsx
import { useEffect, useEffectEvent } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, userName }) {
  const onConnected = useEffectEvent(() => {
    showNotification(`Hi ${userName}, you are now connected!`);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}
```

Now, the effect only depends on `roomId`, so it runs when the user joins a new room â€” not when they simply change their name.
At the same time, the `onConnected` always sees the latest `userName`, even though it's not part of the dependency array.

This is exactly what `useEffectEvent` is for: keeping your Effects stable while still using fresh values.

## ðŸ§° Without `useEffectEvent`

Before React **19.2.0**, You would have to rely on a `ref` to store the latest value manually:

```tsx
import { useEffect, useRef } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, userName }) {
  const lastUserNameRef = useRef(userName);
  lastUserNameRef.current = userName;

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification(`Hi ${lastUserNameRef.current}, you are now connected!`);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
}
```

It works â€” but it's verbose, error-prone, and not very intuitive.
`useEffectEvent` provides a cleaner way to achieve the same thing.


## ðŸŒ Another Example

This pattern isn't just for chat apps. You can use it anytime you want your effect to run only when certain data changes â€” but still read the most up-to-date state inside the effect.

```tsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent((visitedUrl) => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // âœ… Only runs when URL changes
}
```

Here, the effect runs when the `url` changes, but the event callback always uses the latest `numberOfItems` from context â€” no stale data, no extra effect runs.

## ðŸ“š Conclusion
With `useEffectEvent`, you can extract the non-reactive logic from your Effects into Effect Events.
The hook helps developers access the latest reactive values without unnecessarily re-running the effect.
With this small addition to our toolbelt, we can improve readability and performance of our code.


Thank you for reading!

## ðŸ”— References
- [Official useEffectEvent documentation](https://react.dev/reference/react/useEffectEvent)
- [LogRocket article about useEffectEvent](https://blog.logrocket.com/react-useeffectevent)